//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IEmployeeClient {
    checkAvailableCandidateEmployee(email: string | null | undefined): Observable<boolean>;
    getEnterpriseEmployeeList(search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfEnterpriseEmployeeDto>;
    getDetailEnterpriseEmployee(id: string | undefined): Observable<EnterpriseEmployeeDetailDto>;
    getCandidateEmployee(candidateEmployeeEmail: string | null | undefined): Observable<UserMinimalInfo>;
    createEmployee(email: string | null | undefined, enterpriseRoleName: string | null | undefined): Observable<string>;
    updateEmployee(id: string | undefined, enterpriseRoleName: string | null | undefined): Observable<string>;
    deleteEmployee(id: string | undefined): Observable<string>;
    joinEmployee(code: number | undefined): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class EmployeeClient implements IEmployeeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    checkAvailableCandidateEmployee(email: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Employee/CheckAvailableCandidateEmployee?";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAvailableCandidateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAvailableCandidateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckAvailableCandidateEmployee(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnterpriseEmployeeList(search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfEnterpriseEmployeeDto> {
        let url_ = this.baseUrl + "/api/Employee/GetEnterpriseEmployeeList?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnterpriseEmployeeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnterpriseEmployeeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchPageResponseOfEnterpriseEmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchPageResponseOfEnterpriseEmployeeDto>;
        }));
    }

    protected processGetEnterpriseEmployeeList(response: HttpResponseBase): Observable<SearchPageResponseOfEnterpriseEmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchPageResponseOfEnterpriseEmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDetailEnterpriseEmployee(id: string | undefined): Observable<EnterpriseEmployeeDetailDto> {
        let url_ = this.baseUrl + "/api/Employee/GetDetailEnterpriseEmployee?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailEnterpriseEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailEnterpriseEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterpriseEmployeeDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterpriseEmployeeDetailDto>;
        }));
    }

    protected processGetDetailEnterpriseEmployee(response: HttpResponseBase): Observable<EnterpriseEmployeeDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnterpriseEmployeeDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCandidateEmployee(candidateEmployeeEmail: string | null | undefined): Observable<UserMinimalInfo> {
        let url_ = this.baseUrl + "/api/Employee/GetCandidateEmployee?";
        if (candidateEmployeeEmail !== undefined && candidateEmployeeEmail !== null)
            url_ += "CandidateEmployeeEmail=" + encodeURIComponent("" + candidateEmployeeEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCandidateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCandidateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserMinimalInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserMinimalInfo>;
        }));
    }

    protected processGetCandidateEmployee(response: HttpResponseBase): Observable<UserMinimalInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserMinimalInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createEmployee(email: string | null | undefined, enterpriseRoleName: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Employee/CreateEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (enterpriseRoleName !== null && enterpriseRoleName !== undefined)
            content_.append("EnterpriseRoleName", enterpriseRoleName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateEmployee(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateEmployee(id: string | undefined, enterpriseRoleName: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Employee/UpdateEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (enterpriseRoleName !== null && enterpriseRoleName !== undefined)
            content_.append("EnterpriseRoleName", enterpriseRoleName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateEmployee(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEmployee(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Employee/DeleteEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDeleteEmployee(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    joinEmployee(code: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Employee/JoinEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (code === null || code === undefined)
            throw new Error("The parameter 'code' cannot be null.");
        else
            content_.append("Code", code.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processJoinEmployee(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEnterpriseClient {
    getOwned(name: string | null | undefined): Observable<MyEnterpriseDto[]>;
    getMyEnterpriseInfo(id: string | undefined): Observable<MyEnterpriseDto>;
    create(photoFile: any[] | null | undefined, enterpriseTypeId: number | undefined, id: string | undefined, code: string | null | undefined, name: string | null | undefined, description: string | null | undefined, enterpriseType: string | null | undefined, photo: string | null | undefined, phone: string | null | undefined, email: string | null | undefined, address_Id: string | undefined, address_EnterpriseId: string | undefined, address_Street: string | null | undefined, address_SubDistrict: string | null | undefined, address_District: string | null | undefined, address_City: string | null | undefined, address_Province: string | null | undefined, address_PostalCode: string | null | undefined, address_Latitude: number | undefined, address_Longitude: number | undefined): Observable<string>;
    checkAvailableEnterpriseCode(code: string | null | undefined): Observable<boolean>;
    getAvailableEnterpriseCode(name: string | null | undefined): Observable<string[]>;
    getEnterpriseToken(enterpriseId: string | undefined): Observable<EnterpriseTokenDto>;
}

@Injectable({
    providedIn: 'root'
})
export class EnterpriseClient implements IEnterpriseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOwned(name: string | null | undefined): Observable<MyEnterpriseDto[]> {
        let url_ = this.baseUrl + "/api/Enterprise/GetOwned?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwned(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwned(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyEnterpriseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyEnterpriseDto[]>;
        }));
    }

    protected processGetOwned(response: HttpResponseBase): Observable<MyEnterpriseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MyEnterpriseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyEnterpriseInfo(id: string | undefined): Observable<MyEnterpriseDto> {
        let url_ = this.baseUrl + "/api/Enterprise/GetMyEnterpriseInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyEnterpriseInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyEnterpriseInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyEnterpriseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyEnterpriseDto>;
        }));
    }

    protected processGetMyEnterpriseInfo(response: HttpResponseBase): Observable<MyEnterpriseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MyEnterpriseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(photoFile: any[] | null | undefined, enterpriseTypeId: number | undefined, id: string | undefined, code: string | null | undefined, name: string | null | undefined, description: string | null | undefined, enterpriseType: string | null | undefined, photo: string | null | undefined, phone: string | null | undefined, email: string | null | undefined, address_Id: string | undefined, address_EnterpriseId: string | undefined, address_Street: string | null | undefined, address_SubDistrict: string | null | undefined, address_District: string | null | undefined, address_City: string | null | undefined, address_Province: string | null | undefined, address_PostalCode: string | null | undefined, address_Latitude: number | undefined, address_Longitude: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Enterprise/Create?";
        if (photoFile !== undefined && photoFile !== null)
            photoFile && photoFile.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "PhotoFile[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (enterpriseTypeId === null || enterpriseTypeId === undefined)
            throw new Error("The parameter 'enterpriseTypeId' cannot be null.");
        else
            content_.append("EnterpriseTypeId", enterpriseTypeId.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (code !== null && code !== undefined)
            content_.append("Code", code.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (enterpriseType !== null && enterpriseType !== undefined)
            content_.append("EnterpriseType", enterpriseType.toString());
        if (photo !== null && photo !== undefined)
            content_.append("Photo", photo.toString());
        if (phone !== null && phone !== undefined)
            content_.append("Phone", phone.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (address_Id === null || address_Id === undefined)
            throw new Error("The parameter 'address_Id' cannot be null.");
        else
            content_.append("Address.Id", address_Id.toString());
        if (address_EnterpriseId === null || address_EnterpriseId === undefined)
            throw new Error("The parameter 'address_EnterpriseId' cannot be null.");
        else
            content_.append("Address.EnterpriseId", address_EnterpriseId.toString());
        if (address_Street !== null && address_Street !== undefined)
            content_.append("Address.Street", address_Street.toString());
        if (address_SubDistrict !== null && address_SubDistrict !== undefined)
            content_.append("Address.SubDistrict", address_SubDistrict.toString());
        if (address_District !== null && address_District !== undefined)
            content_.append("Address.District", address_District.toString());
        if (address_City !== null && address_City !== undefined)
            content_.append("Address.City", address_City.toString());
        if (address_Province !== null && address_Province !== undefined)
            content_.append("Address.Province", address_Province.toString());
        if (address_PostalCode !== null && address_PostalCode !== undefined)
            content_.append("Address.PostalCode", address_PostalCode.toString());
        if (address_Latitude === null || address_Latitude === undefined)
            throw new Error("The parameter 'address_Latitude' cannot be null.");
        else
            content_.append("Address.Latitude", address_Latitude.toString());
        if (address_Longitude === null || address_Longitude === undefined)
            throw new Error("The parameter 'address_Longitude' cannot be null.");
        else
            content_.append("Address.Longitude", address_Longitude.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkAvailableEnterpriseCode(code: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Enterprise/CheckAvailableEnterpriseCode?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAvailableEnterpriseCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAvailableEnterpriseCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckAvailableEnterpriseCode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAvailableEnterpriseCode(name: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Enterprise/GetAvailableEnterpriseCode?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableEnterpriseCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableEnterpriseCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAvailableEnterpriseCode(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnterpriseToken(enterpriseId: string | undefined): Observable<EnterpriseTokenDto> {
        let url_ = this.baseUrl + "/api/Enterprise/GetEnterpriseToken?";
        if (enterpriseId === null)
            throw new Error("The parameter 'enterpriseId' cannot be null.");
        else if (enterpriseId !== undefined)
            url_ += "EnterpriseId=" + encodeURIComponent("" + enterpriseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnterpriseToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnterpriseToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterpriseTokenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterpriseTokenDto>;
        }));
    }

    protected processGetEnterpriseToken(response: HttpResponseBase): Observable<EnterpriseTokenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnterpriseTokenDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEnterpriseTypeClient {
    getAll(): Observable<EnterpriseTypeDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class EnterpriseTypeClient implements IEnterpriseTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Observable<EnterpriseTypeDto[]> {
        let url_ = this.baseUrl + "/api/EnterpriseType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterpriseTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterpriseTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EnterpriseTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnterpriseTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGoodsClient {
    checkDuplicateBarcode(barcode: string | null | undefined): Observable<boolean>;
    getMyGoodses(search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfMyGoodsDto>;
    getInfoOfGoodsForUpdating(id: string | undefined): Observable<InfoOfGoodsForUpdatingDto>;
    create(name: string | undefined, description: string | null | undefined, goodsTypeId: number | undefined, barcode: string | undefined, photo: string | null | undefined, photoString: string | null | undefined, photoFile: FileParameter | null | undefined, contain: number | undefined, availableOnline: number | undefined, parentBarcode: string | null | undefined, goodsGroups: string[] | null | undefined, price: number | undefined, buyPrice: number | undefined, wholesalerPrice: number | undefined, wholesalerMin: number | undefined, isWholesalerPriceAuto: number | undefined, n: number | undefined, threshold: number | undefined): Observable<string>;
    update(id: string | undefined, barcode: string | null | undefined, name: string | null | undefined, description: string | null | undefined, goodsTypeId: number | undefined, photo: string | null | undefined, photoFile: FileParameter | null | undefined, contain: number | undefined, availableOnline: number | undefined, parentBarcode: string | null | undefined, addGoodsGroups: string[] | null | undefined, removeGoodsGroups: string[] | null | undefined): Observable<string>;
    updateSellingPrice(commad: UpdateGoodsSellingPriceCommand): Observable<string>;
    addStock(commad: AddStockCommand): Observable<string>;
    adjustStock(commad: AdjustStockCommand): Observable<string>;
    getListProductForCashier(search: string | null | undefined, enterpriseId: string | undefined): Observable<MyGoodsForCashierDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class GoodsClient implements IGoodsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    checkDuplicateBarcode(barcode: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Goods/CheckDuplicateBarcode?";
        if (barcode !== undefined && barcode !== null)
            url_ += "Barcode=" + encodeURIComponent("" + barcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDuplicateBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDuplicateBarcode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckDuplicateBarcode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyGoodses(search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfMyGoodsDto> {
        let url_ = this.baseUrl + "/api/Goods/GetMyGoodses?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyGoodses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyGoodses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchPageResponseOfMyGoodsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchPageResponseOfMyGoodsDto>;
        }));
    }

    protected processGetMyGoodses(response: HttpResponseBase): Observable<SearchPageResponseOfMyGoodsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchPageResponseOfMyGoodsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getInfoOfGoodsForUpdating(id: string | undefined): Observable<InfoOfGoodsForUpdatingDto> {
        let url_ = this.baseUrl + "/api/Goods/GetInfoOfGoodsForUpdating?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoOfGoodsForUpdating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoOfGoodsForUpdating(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoOfGoodsForUpdatingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoOfGoodsForUpdatingDto>;
        }));
    }

    protected processGetInfoOfGoodsForUpdating(response: HttpResponseBase): Observable<InfoOfGoodsForUpdatingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoOfGoodsForUpdatingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(name: string | undefined, description: string | null | undefined, goodsTypeId: number | undefined, barcode: string | undefined, photo: string | null | undefined, photoString: string | null | undefined, photoFile: FileParameter | null | undefined, contain: number | undefined, availableOnline: number | undefined, parentBarcode: string | null | undefined, goodsGroups: string[] | null | undefined, price: number | undefined, buyPrice: number | undefined, wholesalerPrice: number | undefined, wholesalerMin: number | undefined, isWholesalerPriceAuto: number | undefined, n: number | undefined, threshold: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Goods/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (goodsTypeId === null || goodsTypeId === undefined)
            throw new Error("The parameter 'goodsTypeId' cannot be null.");
        else
            content_.append("GoodsTypeId", goodsTypeId.toString());
        if (barcode === null || barcode === undefined)
            throw new Error("The parameter 'barcode' cannot be null.");
        else
            content_.append("Barcode", barcode.toString());
        if (photo !== null && photo !== undefined)
            content_.append("Photo", photo.toString());
        if (photoString !== null && photoString !== undefined)
            content_.append("PhotoString", photoString.toString());
        if (photoFile !== null && photoFile !== undefined)
            content_.append("PhotoFile", photoFile.data, photoFile.fileName ? photoFile.fileName : "PhotoFile");
        if (contain === null || contain === undefined)
            throw new Error("The parameter 'contain' cannot be null.");
        else
            content_.append("Contain", contain.toString());
        if (availableOnline === null || availableOnline === undefined)
            throw new Error("The parameter 'availableOnline' cannot be null.");
        else
            content_.append("AvailableOnline", availableOnline.toString());
        if (parentBarcode !== null && parentBarcode !== undefined)
            content_.append("ParentBarcode", parentBarcode.toString());
        if (goodsGroups !== null && goodsGroups !== undefined)
            goodsGroups.forEach(item_ => content_.append("GoodsGroups", item_.toString()));
        if (price === null || price === undefined)
            throw new Error("The parameter 'price' cannot be null.");
        else
            content_.append("Price", price.toString());
        if (buyPrice === null || buyPrice === undefined)
            throw new Error("The parameter 'buyPrice' cannot be null.");
        else
            content_.append("BuyPrice", buyPrice.toString());
        if (wholesalerPrice === null || wholesalerPrice === undefined)
            throw new Error("The parameter 'wholesalerPrice' cannot be null.");
        else
            content_.append("WholesalerPrice", wholesalerPrice.toString());
        if (wholesalerMin === null || wholesalerMin === undefined)
            throw new Error("The parameter 'wholesalerMin' cannot be null.");
        else
            content_.append("WholesalerMin", wholesalerMin.toString());
        if (isWholesalerPriceAuto === null || isWholesalerPriceAuto === undefined)
            throw new Error("The parameter 'isWholesalerPriceAuto' cannot be null.");
        else
            content_.append("IsWholesalerPriceAuto", isWholesalerPriceAuto.toString());
        if (n === null || n === undefined)
            throw new Error("The parameter 'n' cannot be null.");
        else
            content_.append("N", n.toString());
        if (threshold === null || threshold === undefined)
            throw new Error("The parameter 'threshold' cannot be null.");
        else
            content_.append("Threshold", threshold.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string | undefined, barcode: string | null | undefined, name: string | null | undefined, description: string | null | undefined, goodsTypeId: number | undefined, photo: string | null | undefined, photoFile: FileParameter | null | undefined, contain: number | undefined, availableOnline: number | undefined, parentBarcode: string | null | undefined, addGoodsGroups: string[] | null | undefined, removeGoodsGroups: string[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Goods/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (barcode !== null && barcode !== undefined)
            content_.append("Barcode", barcode.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (goodsTypeId === null || goodsTypeId === undefined)
            throw new Error("The parameter 'goodsTypeId' cannot be null.");
        else
            content_.append("GoodsTypeId", goodsTypeId.toString());
        if (photo !== null && photo !== undefined)
            content_.append("Photo", photo.toString());
        if (photoFile !== null && photoFile !== undefined)
            content_.append("PhotoFile", photoFile.data, photoFile.fileName ? photoFile.fileName : "PhotoFile");
        if (contain === null || contain === undefined)
            throw new Error("The parameter 'contain' cannot be null.");
        else
            content_.append("Contain", contain.toString());
        if (availableOnline === null || availableOnline === undefined)
            throw new Error("The parameter 'availableOnline' cannot be null.");
        else
            content_.append("AvailableOnline", availableOnline.toString());
        if (parentBarcode !== null && parentBarcode !== undefined)
            content_.append("ParentBarcode", parentBarcode.toString());
        if (addGoodsGroups !== null && addGoodsGroups !== undefined)
            addGoodsGroups.forEach(item_ => content_.append("AddGoodsGroups", item_.toString()));
        if (removeGoodsGroups !== null && removeGoodsGroups !== undefined)
            removeGoodsGroups.forEach(item_ => content_.append("RemoveGoodsGroups", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateSellingPrice(commad: UpdateGoodsSellingPriceCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Goods/UpdateSellingPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(commad);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSellingPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSellingPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateSellingPrice(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addStock(commad: AddStockCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Goods/AddStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(commad);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddStock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddStock(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    adjustStock(commad: AdjustStockCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Goods/AdjustStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(commad);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdjustStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdjustStock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAdjustStock(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListProductForCashier(search: string | null | undefined, enterpriseId: string | undefined): Observable<MyGoodsForCashierDto[]> {
        let url_ = this.baseUrl + "/api/Goods/GetListProductForCashier?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (enterpriseId === null)
            throw new Error("The parameter 'enterpriseId' cannot be null.");
        else if (enterpriseId !== undefined)
            url_ += "EnterpriseId=" + encodeURIComponent("" + enterpriseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListProductForCashier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListProductForCashier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyGoodsForCashierDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyGoodsForCashierDto[]>;
        }));
    }

    protected processGetListProductForCashier(response: HttpResponseBase): Observable<MyGoodsForCashierDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MyGoodsForCashierDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGoodsGroupClient {
    checkDuplicateGoodsGroupName(name: string | null | undefined): Observable<boolean>;
    getMyGoodsGroups(search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfMyGoodsGroupDto>;
    create(name: string | null | undefined, description: string | null | undefined): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class GoodsGroupClient implements IGoodsGroupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    checkDuplicateGoodsGroupName(name: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/GoodsGroup/CheckDuplicateGoodsGroupName?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDuplicateGoodsGroupName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDuplicateGoodsGroupName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckDuplicateGoodsGroupName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyGoodsGroups(search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfMyGoodsGroupDto> {
        let url_ = this.baseUrl + "/api/GoodsGroup/GetMyGoodsGroups?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyGoodsGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyGoodsGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchPageResponseOfMyGoodsGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchPageResponseOfMyGoodsGroupDto>;
        }));
    }

    protected processGetMyGoodsGroups(response: HttpResponseBase): Observable<SearchPageResponseOfMyGoodsGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchPageResponseOfMyGoodsGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(name: string | null | undefined, description: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsGroup/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGoodsTypeClient {
    getAll(onlyRoot: boolean | undefined): Observable<GoodsTypeDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class GoodsTypeClient implements IGoodsTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(onlyRoot: boolean | undefined): Observable<GoodsTypeDto[]> {
        let url_ = this.baseUrl + "/api/GoodsType/GetAll?";
        if (onlyRoot === null)
            throw new Error("The parameter 'onlyRoot' cannot be null.");
        else if (onlyRoot !== undefined)
            url_ += "OnlyRoot=" + encodeURIComponent("" + onlyRoot) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GoodsTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GoodsTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GoodsTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GoodsTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrderClient {
    createOrderOnline(): Observable<string>;
    finishOrder(): Observable<string>;
    createOrderCashier(total: number | undefined, payment: number | undefined, return: number | undefined, to: string | null | undefined, items: ItemOrdered[] | null | undefined): Observable<string>;
    getEnterpriseOrder(startCreatedAt: Date | null | undefined, endCreatedAt: Date | null | undefined, search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfOrderDto>;
    getEnterpriseOrderDetail(id: string | undefined): Observable<DetailOrderDto>;
}

@Injectable({
    providedIn: 'root'
})
export class OrderClient implements IOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOrderOnline(): Observable<string> {
        let url_ = this.baseUrl + "/api/Order/CreateOrderOnline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrderOnline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrderOnline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateOrderOnline(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    finishOrder(): Observable<string> {
        let url_ = this.baseUrl + "/api/Order/FinishOrder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processFinishOrder(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOrderCashier(total: number | undefined, payment: number | undefined, return: number | undefined, to: string | null | undefined, items: ItemOrdered[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Order/CreateOrderCashier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (total === null || total === undefined)
            throw new Error("The parameter 'total' cannot be null.");
        else
            content_.append("Total", total.toString());
        if (payment === null || payment === undefined)
            throw new Error("The parameter 'payment' cannot be null.");
        else
            content_.append("Payment", payment.toString());
        if (return === null || return === undefined)
            throw new Error("The parameter 'return' cannot be null.");
        else
            content_.append("Return", return.toString());
        if (to !== null && to !== undefined)
            content_.append("To", to.toString());
        if (items !== null && items !== undefined)
            items.forEach(item_ => content_.append("Items", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrderCashier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrderCashier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateOrderCashier(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnterpriseOrder(startCreatedAt: Date | null | undefined, endCreatedAt: Date | null | undefined, search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfOrderDto> {
        let url_ = this.baseUrl + "/api/Order/GetEnterpriseOrder?";
        if (startCreatedAt !== undefined && startCreatedAt !== null)
            url_ += "StartCreatedAt=" + encodeURIComponent(startCreatedAt ? "" + startCreatedAt.toISOString() : "") + "&";
        if (endCreatedAt !== undefined && endCreatedAt !== null)
            url_ += "EndCreatedAt=" + encodeURIComponent(endCreatedAt ? "" + endCreatedAt.toISOString() : "") + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnterpriseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnterpriseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchPageResponseOfOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchPageResponseOfOrderDto>;
        }));
    }

    protected processGetEnterpriseOrder(response: HttpResponseBase): Observable<SearchPageResponseOfOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchPageResponseOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnterpriseOrderDetail(id: string | undefined): Observable<DetailOrderDto> {
        let url_ = this.baseUrl + "/api/Order/GetEnterpriseOrderDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnterpriseOrderDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnterpriseOrderDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DetailOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DetailOrderDto>;
        }));
    }

    protected processGetEnterpriseOrderDetail(response: HttpResponseBase): Observable<DetailOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DetailOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRoleClient {
    getEnterpriseClaim(query: GetAllEnterpriseClaimsQuery | null | undefined): Observable<EnterpriseClaimDto[]>;
    getEnterpriseRoleClaim(id: string | undefined): Observable<EnterpriseRoleDetailDto>;
    getEnterpriseRolePage(search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfEnterpriseRoleDto>;
    getEnterpriseRoleList(search: string | null | undefined): Observable<EnterpriseRoleDto[]>;
    checkDuplicateRoleName(name: string | null | undefined): Observable<boolean>;
    createRole(name: string | null | undefined, claims: RoleClaimItem[] | null | undefined): Observable<string>;
    updateRole(id: string | undefined, name: string | null | undefined, claims: RoleClaimItem[] | null | undefined): Observable<string>;
    deleteRole(id: string | undefined): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class RoleClient implements IRoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEnterpriseClaim(query: GetAllEnterpriseClaimsQuery | null | undefined): Observable<EnterpriseClaimDto[]> {
        let url_ = this.baseUrl + "/api/Role/GetEnterpriseClaim?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnterpriseClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnterpriseClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterpriseClaimDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterpriseClaimDto[]>;
        }));
    }

    protected processGetEnterpriseClaim(response: HttpResponseBase): Observable<EnterpriseClaimDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnterpriseClaimDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnterpriseRoleClaim(id: string | undefined): Observable<EnterpriseRoleDetailDto> {
        let url_ = this.baseUrl + "/api/Role/GetEnterpriseRoleClaim?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnterpriseRoleClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnterpriseRoleClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterpriseRoleDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterpriseRoleDetailDto>;
        }));
    }

    protected processGetEnterpriseRoleClaim(response: HttpResponseBase): Observable<EnterpriseRoleDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnterpriseRoleDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnterpriseRolePage(search: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SearchPageResponseOfEnterpriseRoleDto> {
        let url_ = this.baseUrl + "/api/Role/GetEnterpriseRolePage?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnterpriseRolePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnterpriseRolePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchPageResponseOfEnterpriseRoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchPageResponseOfEnterpriseRoleDto>;
        }));
    }

    protected processGetEnterpriseRolePage(response: HttpResponseBase): Observable<SearchPageResponseOfEnterpriseRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchPageResponseOfEnterpriseRoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnterpriseRoleList(search: string | null | undefined): Observable<EnterpriseRoleDto[]> {
        let url_ = this.baseUrl + "/api/Role/GetEnterpriseRoleList?";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnterpriseRoleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnterpriseRoleList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnterpriseRoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnterpriseRoleDto[]>;
        }));
    }

    protected processGetEnterpriseRoleList(response: HttpResponseBase): Observable<EnterpriseRoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnterpriseRoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkDuplicateRoleName(name: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Role/CheckDuplicateRoleName?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDuplicateRoleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDuplicateRoleName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckDuplicateRoleName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRole(name: string | null | undefined, claims: RoleClaimItem[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Role/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (claims !== null && claims !== undefined)
            claims.forEach(item_ => content_.append("Claims", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateRole(id: string | undefined, name: string | null | undefined, claims: RoleClaimItem[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Role/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (claims !== null && claims !== undefined)
            claims.forEach(item_ => content_.append("Claims", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRole(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Role/DeleteRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class SearchPageResponseOfEnterpriseEmployeeDto implements ISearchPageResponseOfEnterpriseEmployeeDto {
    items?: EnterpriseEmployeeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: ISearchPageResponseOfEnterpriseEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EnterpriseEmployeeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): SearchPageResponseOfEnterpriseEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPageResponseOfEnterpriseEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface ISearchPageResponseOfEnterpriseEmployeeDto {
    items?: EnterpriseEmployeeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class EnterpriseEmployeeDto implements IEnterpriseEmployeeDto {
    userId?: string;
    employeeId?: string;
    employeeName?: string;
    enterpriseRoleName?: string;

    constructor(data?: IEnterpriseEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.enterpriseRoleName = _data["enterpriseRoleName"];
        }
    }

    static fromJS(data: any): EnterpriseEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnterpriseEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["enterpriseRoleName"] = this.enterpriseRoleName;
        return data;
    }
}

export interface IEnterpriseEmployeeDto {
    userId?: string;
    employeeId?: string;
    employeeName?: string;
    enterpriseRoleName?: string;
}

export class EnterpriseEmployeeDetailDto implements IEnterpriseEmployeeDetailDto {
    userId?: string;
    employeeId?: string;
    email?: string;
    name?: string;
    enterpriseRoleName?: string;

    constructor(data?: IEnterpriseEmployeeDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.employeeId = _data["employeeId"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.enterpriseRoleName = _data["enterpriseRoleName"];
        }
    }

    static fromJS(data: any): EnterpriseEmployeeDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnterpriseEmployeeDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["employeeId"] = this.employeeId;
        data["email"] = this.email;
        data["name"] = this.name;
        data["enterpriseRoleName"] = this.enterpriseRoleName;
        return data;
    }
}

export interface IEnterpriseEmployeeDetailDto {
    userId?: string;
    employeeId?: string;
    email?: string;
    name?: string;
    enterpriseRoleName?: string;
}

export class UserMinimalInfo implements IUserMinimalInfo {
    id?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUserMinimalInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserMinimalInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserMinimalInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

export interface IUserMinimalInfo {
    id?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
}

export class MyEnterpriseDto implements IMyEnterpriseDto {
    id?: string;
    code?: string;
    name?: string;
    photo?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    enterpriseType?: string;
    address?: string | undefined;
    owned?: boolean;

    constructor(data?: IMyEnterpriseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.photo = _data["photo"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.enterpriseType = _data["enterpriseType"];
            this.address = _data["address"];
            this.owned = _data["owned"];
        }
    }

    static fromJS(data: any): MyEnterpriseDto {
        data = typeof data === 'object' ? data : {};
        let result = new MyEnterpriseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["photo"] = this.photo;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["enterpriseType"] = this.enterpriseType;
        data["address"] = this.address;
        data["owned"] = this.owned;
        return data;
    }
}

export interface IMyEnterpriseDto {
    id?: string;
    code?: string;
    name?: string;
    photo?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    enterpriseType?: string;
    address?: string | undefined;
    owned?: boolean;
}

export class EnterpriseTokenDto implements IEnterpriseTokenDto {
    token?: string;

    constructor(data?: IEnterpriseTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): EnterpriseTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnterpriseTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IEnterpriseTokenDto {
    token?: string;
}

export class EnterpriseTypeDto implements IEnterpriseTypeDto {
    id?: number;
    name?: string;
    provide?: string;

    constructor(data?: IEnterpriseTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.provide = _data["provide"];
        }
    }

    static fromJS(data: any): EnterpriseTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnterpriseTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["provide"] = this.provide;
        return data;
    }
}

export interface IEnterpriseTypeDto {
    id?: number;
    name?: string;
    provide?: string;
}

export class SearchPageResponseOfMyGoodsDto implements ISearchPageResponseOfMyGoodsDto {
    items?: MyGoodsDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: ISearchPageResponseOfMyGoodsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MyGoodsDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): SearchPageResponseOfMyGoodsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPageResponseOfMyGoodsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface ISearchPageResponseOfMyGoodsDto {
    items?: MyGoodsDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MyGoodsDto implements IMyGoodsDto {
    id?: string;
    enterpriseId?: string;
    barcode?: string;
    name?: string;
    description?: string | undefined;
    photo?: string | undefined;
    goodsType?: string;
    contain?: number;
    price?: number;
    wholesalerPrice?: number;
    n?: number;
    stock?: string;

    constructor(data?: IMyGoodsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enterpriseId = _data["enterpriseId"];
            this.barcode = _data["barcode"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.photo = _data["photo"];
            this.goodsType = _data["goodsType"];
            this.contain = _data["contain"];
            this.price = _data["price"];
            this.wholesalerPrice = _data["wholesalerPrice"];
            this.n = _data["n"];
            this.stock = _data["stock"];
        }
    }

    static fromJS(data: any): MyGoodsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MyGoodsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enterpriseId"] = this.enterpriseId;
        data["barcode"] = this.barcode;
        data["name"] = this.name;
        data["description"] = this.description;
        data["photo"] = this.photo;
        data["goodsType"] = this.goodsType;
        data["contain"] = this.contain;
        data["price"] = this.price;
        data["wholesalerPrice"] = this.wholesalerPrice;
        data["n"] = this.n;
        data["stock"] = this.stock;
        return data;
    }
}

export interface IMyGoodsDto {
    id?: string;
    enterpriseId?: string;
    barcode?: string;
    name?: string;
    description?: string | undefined;
    photo?: string | undefined;
    goodsType?: string;
    contain?: number;
    price?: number;
    wholesalerPrice?: number;
    n?: number;
    stock?: string;
}

export class InfoOfGoodsForUpdatingDto implements IInfoOfGoodsForUpdatingDto {
    id?: string;
    enterpriseId?: string;
    barcode?: string;
    name?: string;
    goodsTypeId?: number;
    description?: string | undefined;
    photo?: string | undefined;
    contain?: number;
    n?: number;
    price?: number;
    buyPrice?: number;
    baseBuyPrice?: number;
    wholesalerPrice?: number;
    wholesalerMin?: number;
    isWholesalerPriceAuto?: boolean;
    availableOnline?: boolean;
    threshold?: number;
    parent?: InfoOfParentOfGoodsForUpdatingDto | undefined;
    groups?: InfoOfGroupOfGoodsForUpdatingDto[];

    constructor(data?: IInfoOfGoodsForUpdatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enterpriseId = _data["enterpriseId"];
            this.barcode = _data["barcode"];
            this.name = _data["name"];
            this.goodsTypeId = _data["goodsTypeId"];
            this.description = _data["description"];
            this.photo = _data["photo"];
            this.contain = _data["contain"];
            this.n = _data["n"];
            this.price = _data["price"];
            this.buyPrice = _data["buyPrice"];
            this.baseBuyPrice = _data["baseBuyPrice"];
            this.wholesalerPrice = _data["wholesalerPrice"];
            this.wholesalerMin = _data["wholesalerMin"];
            this.isWholesalerPriceAuto = _data["isWholesalerPriceAuto"];
            this.availableOnline = _data["availableOnline"];
            this.threshold = _data["threshold"];
            this.parent = _data["parent"] ? InfoOfParentOfGoodsForUpdatingDto.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(InfoOfGroupOfGoodsForUpdatingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InfoOfGoodsForUpdatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoOfGoodsForUpdatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enterpriseId"] = this.enterpriseId;
        data["barcode"] = this.barcode;
        data["name"] = this.name;
        data["goodsTypeId"] = this.goodsTypeId;
        data["description"] = this.description;
        data["photo"] = this.photo;
        data["contain"] = this.contain;
        data["n"] = this.n;
        data["price"] = this.price;
        data["buyPrice"] = this.buyPrice;
        data["baseBuyPrice"] = this.baseBuyPrice;
        data["wholesalerPrice"] = this.wholesalerPrice;
        data["wholesalerMin"] = this.wholesalerMin;
        data["isWholesalerPriceAuto"] = this.isWholesalerPriceAuto;
        data["availableOnline"] = this.availableOnline;
        data["threshold"] = this.threshold;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInfoOfGoodsForUpdatingDto {
    id?: string;
    enterpriseId?: string;
    barcode?: string;
    name?: string;
    goodsTypeId?: number;
    description?: string | undefined;
    photo?: string | undefined;
    contain?: number;
    n?: number;
    price?: number;
    buyPrice?: number;
    baseBuyPrice?: number;
    wholesalerPrice?: number;
    wholesalerMin?: number;
    isWholesalerPriceAuto?: boolean;
    availableOnline?: boolean;
    threshold?: number;
    parent?: InfoOfParentOfGoodsForUpdatingDto | undefined;
    groups?: InfoOfGroupOfGoodsForUpdatingDto[];
}

export class InfoOfParentOfGoodsForUpdatingDto implements IInfoOfParentOfGoodsForUpdatingDto {
    id?: string;
    barcode?: string;
    name?: string;

    constructor(data?: IInfoOfParentOfGoodsForUpdatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.barcode = _data["barcode"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InfoOfParentOfGoodsForUpdatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoOfParentOfGoodsForUpdatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["barcode"] = this.barcode;
        data["name"] = this.name;
        return data;
    }
}

export interface IInfoOfParentOfGoodsForUpdatingDto {
    id?: string;
    barcode?: string;
    name?: string;
}

export class InfoOfGroupOfGoodsForUpdatingDto implements IInfoOfGroupOfGoodsForUpdatingDto {
    id?: string;
    name?: string;
    members?: InfoOfGroupMemberOfGoodsForUpdatingDto[];

    constructor(data?: IInfoOfGroupOfGoodsForUpdatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(InfoOfGroupMemberOfGoodsForUpdatingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InfoOfGroupOfGoodsForUpdatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoOfGroupOfGoodsForUpdatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInfoOfGroupOfGoodsForUpdatingDto {
    id?: string;
    name?: string;
    members?: InfoOfGroupMemberOfGoodsForUpdatingDto[];
}

export class InfoOfGroupMemberOfGoodsForUpdatingDto implements IInfoOfGroupMemberOfGoodsForUpdatingDto {
    id?: string;
    barcode?: string;
    name?: string;

    constructor(data?: IInfoOfGroupMemberOfGoodsForUpdatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.barcode = _data["barcode"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InfoOfGroupMemberOfGoodsForUpdatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoOfGroupMemberOfGoodsForUpdatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["barcode"] = this.barcode;
        data["name"] = this.name;
        return data;
    }
}

export interface IInfoOfGroupMemberOfGoodsForUpdatingDto {
    id?: string;
    barcode?: string;
    name?: string;
}

export class UpdateGoodsSellingPriceCommand implements IUpdateGoodsSellingPriceCommand {
    id?: string;
    price?: number;
    wholesalerPrice?: number;
    wholesalerMin?: number;
    isWholesalerPriceAuto?: boolean;

    constructor(data?: IUpdateGoodsSellingPriceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.wholesalerPrice = _data["wholesalerPrice"];
            this.wholesalerMin = _data["wholesalerMin"];
            this.isWholesalerPriceAuto = _data["isWholesalerPriceAuto"];
        }
    }

    static fromJS(data: any): UpdateGoodsSellingPriceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoodsSellingPriceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["wholesalerPrice"] = this.wholesalerPrice;
        data["wholesalerMin"] = this.wholesalerMin;
        data["isWholesalerPriceAuto"] = this.isWholesalerPriceAuto;
        return data;
    }
}

export interface IUpdateGoodsSellingPriceCommand {
    id?: string;
    price?: number;
    wholesalerPrice?: number;
    wholesalerMin?: number;
    isWholesalerPriceAuto?: boolean;
}

export class AddStockCommand implements IAddStockCommand {
    id?: string;
    increment?: number;
    buyPriceTotal?: number;

    constructor(data?: IAddStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.increment = _data["increment"];
            this.buyPriceTotal = _data["buyPriceTotal"];
        }
    }

    static fromJS(data: any): AddStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["increment"] = this.increment;
        data["buyPriceTotal"] = this.buyPriceTotal;
        return data;
    }
}

export interface IAddStockCommand {
    id?: string;
    increment?: number;
    buyPriceTotal?: number;
}

export class AdjustStockCommand implements IAdjustStockCommand {
    id?: string;
    actualStock?: number;

    constructor(data?: IAdjustStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.actualStock = _data["actualStock"];
        }
    }

    static fromJS(data: any): AdjustStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AdjustStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["actualStock"] = this.actualStock;
        return data;
    }
}

export interface IAdjustStockCommand {
    id?: string;
    actualStock?: number;
}

export class MyGoodsForCashierDto implements IMyGoodsForCashierDto {
    id?: string;
    enterpriseId?: string;
    barcode?: string;
    name?: string;
    price?: number;
    wholesalerPrice?: number;
    wholesalerMin?: number;
    isWholesalerPriceAuto?: boolean;

    constructor(data?: IMyGoodsForCashierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enterpriseId = _data["enterpriseId"];
            this.barcode = _data["barcode"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.wholesalerPrice = _data["wholesalerPrice"];
            this.wholesalerMin = _data["wholesalerMin"];
            this.isWholesalerPriceAuto = _data["isWholesalerPriceAuto"];
        }
    }

    static fromJS(data: any): MyGoodsForCashierDto {
        data = typeof data === 'object' ? data : {};
        let result = new MyGoodsForCashierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enterpriseId"] = this.enterpriseId;
        data["barcode"] = this.barcode;
        data["name"] = this.name;
        data["price"] = this.price;
        data["wholesalerPrice"] = this.wholesalerPrice;
        data["wholesalerMin"] = this.wholesalerMin;
        data["isWholesalerPriceAuto"] = this.isWholesalerPriceAuto;
        return data;
    }
}

export interface IMyGoodsForCashierDto {
    id?: string;
    enterpriseId?: string;
    barcode?: string;
    name?: string;
    price?: number;
    wholesalerPrice?: number;
    wholesalerMin?: number;
    isWholesalerPriceAuto?: boolean;
}

export class SearchPageResponseOfMyGoodsGroupDto implements ISearchPageResponseOfMyGoodsGroupDto {
    items?: MyGoodsGroupDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: ISearchPageResponseOfMyGoodsGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MyGoodsGroupDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): SearchPageResponseOfMyGoodsGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPageResponseOfMyGoodsGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface ISearchPageResponseOfMyGoodsGroupDto {
    items?: MyGoodsGroupDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MyGoodsGroupDto implements IMyGoodsGroupDto {
    id?: string;
    name?: string;
    members?: MyGoodsGroupMemberDto[];

    constructor(data?: IMyGoodsGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(MyGoodsGroupMemberDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MyGoodsGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new MyGoodsGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMyGoodsGroupDto {
    id?: string;
    name?: string;
    members?: MyGoodsGroupMemberDto[];
}

export class MyGoodsGroupMemberDto implements IMyGoodsGroupMemberDto {
    id?: string;
    name?: string;
    photoUrl?: string | undefined;

    constructor(data?: IMyGoodsGroupMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.photoUrl = _data["photoUrl"];
        }
    }

    static fromJS(data: any): MyGoodsGroupMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new MyGoodsGroupMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["photoUrl"] = this.photoUrl;
        return data;
    }
}

export interface IMyGoodsGroupMemberDto {
    id?: string;
    name?: string;
    photoUrl?: string | undefined;
}

export class GoodsTypeDto implements IGoodsTypeDto {
    id?: number;
    name?: string;
    parentGoodsTypeId?: number | undefined;
    subGoodsTypes?: GoodsTypeDto[] | undefined;

    constructor(data?: IGoodsTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentGoodsTypeId = _data["parentGoodsTypeId"];
            if (Array.isArray(_data["subGoodsTypes"])) {
                this.subGoodsTypes = [] as any;
                for (let item of _data["subGoodsTypes"])
                    this.subGoodsTypes!.push(GoodsTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GoodsTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoodsTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentGoodsTypeId"] = this.parentGoodsTypeId;
        if (Array.isArray(this.subGoodsTypes)) {
            data["subGoodsTypes"] = [];
            for (let item of this.subGoodsTypes)
                data["subGoodsTypes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGoodsTypeDto {
    id?: number;
    name?: string;
    parentGoodsTypeId?: number | undefined;
    subGoodsTypes?: GoodsTypeDto[] | undefined;
}

export class ItemOrdered implements IItemOrdered {
    goodsId?: string;
    isWholesalerPrice?: number;
    discountItem?: number;
    discountItemTotal?: number;
    pricePerItem?: number;
    pricePerItemAfterDiscount?: number;
    priceTotal?: number;
    priceTotalAfterDiscount?: number;
    priceTotalFinal?: number;
    n?: number;

    constructor(data?: IItemOrdered) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.goodsId = _data["goodsId"];
            this.isWholesalerPrice = _data["isWholesalerPrice"];
            this.discountItem = _data["discountItem"];
            this.discountItemTotal = _data["discountItemTotal"];
            this.pricePerItem = _data["pricePerItem"];
            this.pricePerItemAfterDiscount = _data["pricePerItemAfterDiscount"];
            this.priceTotal = _data["priceTotal"];
            this.priceTotalAfterDiscount = _data["priceTotalAfterDiscount"];
            this.priceTotalFinal = _data["priceTotalFinal"];
            this.n = _data["n"];
        }
    }

    static fromJS(data: any): ItemOrdered {
        data = typeof data === 'object' ? data : {};
        let result = new ItemOrdered();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goodsId"] = this.goodsId;
        data["isWholesalerPrice"] = this.isWholesalerPrice;
        data["discountItem"] = this.discountItem;
        data["discountItemTotal"] = this.discountItemTotal;
        data["pricePerItem"] = this.pricePerItem;
        data["pricePerItemAfterDiscount"] = this.pricePerItemAfterDiscount;
        data["priceTotal"] = this.priceTotal;
        data["priceTotalAfterDiscount"] = this.priceTotalAfterDiscount;
        data["priceTotalFinal"] = this.priceTotalFinal;
        data["n"] = this.n;
        return data;
    }
}

export interface IItemOrdered {
    goodsId?: string;
    isWholesalerPrice?: number;
    discountItem?: number;
    discountItemTotal?: number;
    pricePerItem?: number;
    pricePerItemAfterDiscount?: number;
    priceTotal?: number;
    priceTotalAfterDiscount?: number;
    priceTotalFinal?: number;
    n?: number;
}

export class SearchPageResponseOfOrderDto implements ISearchPageResponseOfOrderDto {
    items?: OrderDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: ISearchPageResponseOfOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): SearchPageResponseOfOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPageResponseOfOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface ISearchPageResponseOfOrderDto {
    items?: OrderDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class OrderDto implements IOrderDto {
    id?: string;
    total?: number;
    payment?: number;
    return?: number;
    paymentMethod?: string;
    orderProgress?: string;
    isOnline?: boolean;
    createdAt?: Date;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.total = _data["total"];
            this.payment = _data["payment"];
            this.return = _data["return"];
            this.paymentMethod = _data["paymentMethod"];
            this.orderProgress = _data["orderProgress"];
            this.isOnline = _data["isOnline"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["total"] = this.total;
        data["payment"] = this.payment;
        data["return"] = this.return;
        data["paymentMethod"] = this.paymentMethod;
        data["orderProgress"] = this.orderProgress;
        data["isOnline"] = this.isOnline;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IOrderDto {
    id?: string;
    total?: number;
    payment?: number;
    return?: number;
    paymentMethod?: string;
    orderProgress?: string;
    isOnline?: boolean;
    createdAt?: Date;
}

export class DetailOrderDto implements IDetailOrderDto {
    id?: string;
    total?: number;
    payment?: number;
    return?: number;
    paymentMethodName?: string;
    orderProgresses?: OrderProgressList[] | undefined;
    isOnline?: boolean;
    createdAt?: Date;
    goodsOrdereds?: OrderGoodsList[] | undefined;
    to?: string | undefined;
    createdById?: string;
    createdByName?: string;

    constructor(data?: IDetailOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.total = _data["total"];
            this.payment = _data["payment"];
            this.return = _data["return"];
            this.paymentMethodName = _data["paymentMethodName"];
            if (Array.isArray(_data["orderProgresses"])) {
                this.orderProgresses = [] as any;
                for (let item of _data["orderProgresses"])
                    this.orderProgresses!.push(OrderProgressList.fromJS(item));
            }
            this.isOnline = _data["isOnline"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["goodsOrdereds"])) {
                this.goodsOrdereds = [] as any;
                for (let item of _data["goodsOrdereds"])
                    this.goodsOrdereds!.push(OrderGoodsList.fromJS(item));
            }
            this.to = _data["to"];
            this.createdById = _data["createdById"];
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): DetailOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["total"] = this.total;
        data["payment"] = this.payment;
        data["return"] = this.return;
        data["paymentMethodName"] = this.paymentMethodName;
        if (Array.isArray(this.orderProgresses)) {
            data["orderProgresses"] = [];
            for (let item of this.orderProgresses)
                data["orderProgresses"].push(item.toJSON());
        }
        data["isOnline"] = this.isOnline;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.goodsOrdereds)) {
            data["goodsOrdereds"] = [];
            for (let item of this.goodsOrdereds)
                data["goodsOrdereds"].push(item.toJSON());
        }
        data["to"] = this.to;
        data["createdById"] = this.createdById;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IDetailOrderDto {
    id?: string;
    total?: number;
    payment?: number;
    return?: number;
    paymentMethodName?: string;
    orderProgresses?: OrderProgressList[] | undefined;
    isOnline?: boolean;
    createdAt?: Date;
    goodsOrdereds?: OrderGoodsList[] | undefined;
    to?: string | undefined;
    createdById?: string;
    createdByName?: string;
}

export class OrderProgressList implements IOrderProgressList {
    id?: string;
    createdAt?: Date;
    name?: string;

    constructor(data?: IOrderProgressList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OrderProgressList {
        data = typeof data === 'object' ? data : {};
        let result = new OrderProgressList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }
}

export interface IOrderProgressList {
    id?: string;
    createdAt?: Date;
    name?: string;
}

export class OrderGoodsList implements IOrderGoodsList {
    id?: string;
    barcode?: string;
    name?: string;
    isWholesalerPrice?: boolean;
    discountItem?: number;
    discountItemTotal?: number;
    pricePerItem?: number;
    pricePerItemAfterDiscount?: number;
    priceTotal?: number;
    priceTotalAfterDiscount?: number;
    priceTotalFinal?: number;
    n?: number;

    constructor(data?: IOrderGoodsList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.barcode = _data["barcode"];
            this.name = _data["name"];
            this.isWholesalerPrice = _data["isWholesalerPrice"];
            this.discountItem = _data["discountItem"];
            this.discountItemTotal = _data["discountItemTotal"];
            this.pricePerItem = _data["pricePerItem"];
            this.pricePerItemAfterDiscount = _data["pricePerItemAfterDiscount"];
            this.priceTotal = _data["priceTotal"];
            this.priceTotalAfterDiscount = _data["priceTotalAfterDiscount"];
            this.priceTotalFinal = _data["priceTotalFinal"];
            this.n = _data["n"];
        }
    }

    static fromJS(data: any): OrderGoodsList {
        data = typeof data === 'object' ? data : {};
        let result = new OrderGoodsList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["barcode"] = this.barcode;
        data["name"] = this.name;
        data["isWholesalerPrice"] = this.isWholesalerPrice;
        data["discountItem"] = this.discountItem;
        data["discountItemTotal"] = this.discountItemTotal;
        data["pricePerItem"] = this.pricePerItem;
        data["pricePerItemAfterDiscount"] = this.pricePerItemAfterDiscount;
        data["priceTotal"] = this.priceTotal;
        data["priceTotalAfterDiscount"] = this.priceTotalAfterDiscount;
        data["priceTotalFinal"] = this.priceTotalFinal;
        data["n"] = this.n;
        return data;
    }
}

export interface IOrderGoodsList {
    id?: string;
    barcode?: string;
    name?: string;
    isWholesalerPrice?: boolean;
    discountItem?: number;
    discountItemTotal?: number;
    pricePerItem?: number;
    pricePerItemAfterDiscount?: number;
    priceTotal?: number;
    priceTotalAfterDiscount?: number;
    priceTotalFinal?: number;
    n?: number;
}

export class EnterpriseClaimDto implements IEnterpriseClaimDto {
    id?: string;
    context?: string;
    feature?: string;
    action?: string;
    description?: string;

    constructor(data?: IEnterpriseClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.context = _data["context"];
            this.feature = _data["feature"];
            this.action = _data["action"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): EnterpriseClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnterpriseClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["context"] = this.context;
        data["feature"] = this.feature;
        data["action"] = this.action;
        data["description"] = this.description;
        return data;
    }
}

export interface IEnterpriseClaimDto {
    id?: string;
    context?: string;
    feature?: string;
    action?: string;
    description?: string;
}

export class GetAllEnterpriseClaimsQuery implements IGetAllEnterpriseClaimsQuery {

    constructor(data?: IGetAllEnterpriseClaimsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetAllEnterpriseClaimsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllEnterpriseClaimsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetAllEnterpriseClaimsQuery {
}

export class EnterpriseRoleDetailDto implements IEnterpriseRoleDetailDto {
    id?: string;
    name?: string;
    claims?: string[];

    constructor(data?: IEnterpriseRoleDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(item);
            }
        }
    }

    static fromJS(data: any): EnterpriseRoleDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnterpriseRoleDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item);
        }
        return data;
    }
}

export interface IEnterpriseRoleDetailDto {
    id?: string;
    name?: string;
    claims?: string[];
}

export class SearchPageResponseOfEnterpriseRoleDto implements ISearchPageResponseOfEnterpriseRoleDto {
    items?: EnterpriseRoleDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: ISearchPageResponseOfEnterpriseRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EnterpriseRoleDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): SearchPageResponseOfEnterpriseRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPageResponseOfEnterpriseRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface ISearchPageResponseOfEnterpriseRoleDto {
    items?: EnterpriseRoleDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class EnterpriseRoleDto implements IEnterpriseRoleDto {
    id?: string;
    name?: string;

    constructor(data?: IEnterpriseRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EnterpriseRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnterpriseRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IEnterpriseRoleDto {
    id?: string;
    name?: string;
}

export class RoleClaimItem implements IRoleClaimItem {
    id?: string;
    authorize?: number;

    constructor(data?: IRoleClaimItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.authorize = _data["authorize"];
        }
    }

    static fromJS(data: any): RoleClaimItem {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaimItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["authorize"] = this.authorize;
        return data;
    }
}

export interface IRoleClaimItem {
    id?: string;
    authorize?: number;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}